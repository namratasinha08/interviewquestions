#P1
##EASY
###BC
1. If an interface annotated with @FunctionalInterface, java complier ensures that interface has ________ method.

A. only one abstract
B. default 
C. final
D. static

Answer: A 

#P1
##EASY
###TF
2. Is @FunctionalInterface annotation is mandatory for every interface with a single abstract method?

A. Yes
B. No

Answer: B
Explanation: Not necessarily because the compiler will consider it as a functional interface when it has only one abstract method. 

#P1
##EASY
###TF
3: Is it possible to have default and static methods in the functional interface?

A. Yes
B. No

Answer: A 
Explanation: We can have any number of default and static methods but can contain only one abstract method. 


4: How many default methods can we have in the functional interface?

    A. only one 
    B. two
    C. many
    D. four

Answer: C 

Explanation: A functional interface can have any number of default methods with only one abstract method.


5: Is Functional Interface related to the Lambda Expression?

    A. Yes
    B. No

Answer: A 
Explanation:  The functional interface has been introduced in Java 8 to support the lambda expression, lambda expression is the instance of a functional interface.


6: What should be in Line 7 to print "HelloWorld" using lambda expression and functional interface?

@FunctionalInterface
interface Greetings {
	void greet();
}

public class test {
	public static void main(String[] args) {
		Line 7
		g.greet(); // Output: HelloWorld

	}
} 

    A. Greetings g = () -> System.out.println("HelloWorld"); 
    B. Greet g = () -> System.out.println("HelloWorld");
    C. Greetings g : System.out.println("HelloWorld");
    D. Greet g : System.out.println("HelloWorld");

Answer: A 


7: Which is not a java built-in examples for functional interfaces.


    A. Runnable - Used in Multithreading , which has run() method    
    B. Callable - Used to wrap a text and pass to a thread , which has call() method
    C. Comparable - Used to compare between the objects in the class, which has compareTo() method
    D. iterable -  Used to iterate by calling the Iterable iterator() method

Answer: D 

8: The Anonymous classes should have _____ method so that it can be converted into lambda expression.
   
    A. only one abstract
    B. default 
    C. final
    D. static

Answer: A 

9: Does lambda expression execute on its own? 

    A. Yes
    B. No

Answer: B 
Explanation : It is used to implement a method defined by a functional interface.


10: Which is not a kind of Functional Interfaces in Java 8.

    A. Consumer - which takes only one argument
    B. Predicate - which takes one argument and returns the result as a boolean value
    C. Supplier - which does not take any arguments and returns a single result.
    D. Runnable - Used in Multithreading , which has run() method   

Answer: D 

11: A functional interface can extend the interface only when there are _____ in it.

    A. only one abstract
    B. no abstract methods
    C. no final methods
    D. only one final methods

Answer: B
Explanation: If it has an abstract method then it will be an invalid functional interface.

12: _________ is also called functional interfaces, having only one abstract method and multiple default methods.

    A. Single Abstract Method.
    B. Lambda expression
    C. abstarct methods
    D. None of the above

Answer: A 

13: Does the functional interface allows static methods?

    A. Yes
    B. No

Answer: A
Explanation:  JDK 8 allows static methods in the interface, before this only one abstract method is allowed in functional interface.


14: Is this a functional interface code snippet?
public interface Circle {
    public abstract void draw();
}

    A. Yes
    B. No

Answer: A
Explanation: This is a functional interface, since there is only one abstract method
	

15: Which is the syntax for the consumer functional interface?

    A. Consumer<Integer> consumer = (value) -> System.out.println(value);
    B. Consumer<Integer> consumer = () -> System.out.println(value);
    C. Consumer<Integer> consumer = () -> System.out.println();
    D. None of the above

Answer: A 
Explanation:  which accepts only one argument and has no return value. 



16: Which is the syntax of the Predicate Functional Interface.

    A. public interface Predicate<> {
       boolean test(t);}
    B. public interface Predicate<T> {
       boolean test(T t);}
    C. public interface Predicate<T> {
       boolean test();}
    D. None of the above

Answer: B 
Explanation: A function that accepts an argument and returns a boolean value as an answer


17: Which one is the Syntax of Supplier Functional Interface in Java8?

    A. public interface Supplier<T>{
       T get(); }
    B. @FunctionalInterface
       public interface Supplier<>{
       T get(); }
    C. @FunctionalInterface
       public interface Supplier<T>{
       T get(); }
    D. public interface Supplier<T t>{
       T get(); }


Answer: C 
Explanation: which does not take any input or argument and yet returns a single output. 

	
18: Is there any limit for static and default methods in the functional interface?

    A. Yes
    B. No

Answer: B 
Explanation: We can add any number of static and default methods in the functional interface in java 8.

	
 19:Which one will be the output of following code snippet.
@FunctionalInterface
interface Arithmetic {  
    void addition(String msg);  
    void subtraction();
}
	
    A. Returns void
    B. Compile time error
    C. Run time error
    D. None of the above

Answer: B 
Explanation: It will throw a compile time error that Arithmetic is not a functional interface, since it has 2 abstract methods.
	

	
20: Which will be the correct lambda expression for the below method sum.

import java.util.Scanner;  
public class Addition {
    public static void main(String[] args) {
    int x, y, sum;  
        Scanner sc = new Scanner(System.in);  
        System.out.print("Enter the first number: ");  
        x = sc.nextInt();  
        System.out.print("Enter the second number: ");  
        y = sc.nextInt();  
        sum = sum(x, y);  
        System.out.println("The sum of two numbers x and y is: " + sum); 
   } 
   public static int Sum(int a, int b)  {  
       int sum = a + b;  
       return sum;  
   }  
}
	

    A. public class Main{ 
         public static void main(String args[]){ 
          Sum sum = (a,b) -> a+b;
          System.out.print(sum.add(2,3));  
         }  
        }  
       interface Sum{
       int add(int a, int b);
       }
	B. public class Main{ 
         public static void main(String args[]){ 
          Sum sum = a+b;
          System.out.print(sum.add(2,3));  
         }  
        }  
       interface Sum{
       int add(int a, int b);
       }
    C. public class Main{ 
         public static void main(String args[]){ 
          Sum sum = (a,b) : a+b;
          System.out.print(sum.add(2,3));  
         }  
        }  
       interface Sum{
       int add(int a, int b);
       }
    D. None of the above

Answer: A 
Explanation: A lambda expression is a short block of code that takes in parameters and returns a value. Which is similar to methods, but they do not need a name(Function name) and they can be implemented right in the body of a method.
	
	
21: Which is the correct Lambda expresssion converted from the below Anonymous class.
 
public class AnonymousClassExample  {
 
    public static void main(String[] args) {
 
        Runnable runnable = new Runnable(){
            public void run(){
                System.out.println("Convertion of Anonymous class into Lamda");
            }
        };
        runnable.run();
    }
}

A. public class AnonymousClassExample {
     public static void main(String[] args) {
        Runnable runnable = () -> {
            System.out.println("Convertion of Anonymous class into Lamda");
        };
        runnable.run();
     }
   }
B. public class AnonymousClassExample {
     public static void main(String[] args) {
        Runnable runnable ;
            System.out.println("Convertion of Anonymous class into Lamda");
        }
        runnable.run();
   }
C. public class AnonymousClassExample {
     public static void main(String[] args) {
        Runnable runnable -> ;
            System.out.println("Convertion of Anonymous class into Lamda");
        }
        runnable.run();
     }
D. None of the above
	
Answer: A 
Explanation: Functional interface can be instantiated using lambda expression instead of AnonymousClass. 


22: What will be the output for the following code snippet.

interface Single{  
    void say(String msg);   // abstract method  
}  
@FunctionalInterface  
interface Double extends Single{  
    void doIt();  
    System.out.println("welcome");
}


    A. Compile time error
    B. Run time error
    C. welcome
    D. None of the above

Answer: A 
Explanation: When a functional interface extends another interface it should not contain any abstract methods.







