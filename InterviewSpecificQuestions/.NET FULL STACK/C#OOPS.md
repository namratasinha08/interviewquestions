## Technical

1. What is meant by object-oriented programming?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 
    
- Object-oriented programming (OOP) is an approach to programming where software is primarily designed by using objects (essentially data) that interact with each other. 

- When different pieces of data are put together, they come to form the software. OOP is an alternative to functional or procedural programming and it’s also the approach used by C#.

</blockquote>

</details>

---

2. What is a Class in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

- In C#, a class is a user-defined blueprint from which objects are created. It brings various types of data together to form a single unit. 

- A class is a data structure that may contain data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, finalizers, and static constructors), and nested types

</blockquote>

</details>

---

3. What is an Object in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

A class or struct definition is like a blueprint that specifies what the type can do. An object is basically a block of memory that has been allocated and configured according to the blueprint. A program may create many objects of the same class. Objects are also called instances, and they can be stored in either a named variable or in an array or collection. Client code is the code that uses these variables to call the methods and access the public properties of the object. In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.

</blockquote>

</details>

---

4. Can you define a Method in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

A method is a code block that contains a series of statements. A program causes the statements to be executed by calling the method and specifying any required method arguments. In C#, every executed instruction is performed in the context of a method.

The Main method is the entry point for every C# application and it's called by the common language runtime (CLR) when the program is started. In an application that uses top-level statements, the Main method is generated by the compiler and contains all top-level statements.

</blockquote>

</details>

---

5. What is meant by Structures in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

The struct (structure) is like a class in C# that is used to store data. However, unlike classes, a struct is a value type.

Suppose we want to store the name and age of a person. We can create two variables: name and age and store value.

However, suppose we want to store the same information of multiple people.

In this case, creating variables for an individual person might be a tedious task. To overcome this we can create a struct that stores name and age. Now, this struct can be used for every person.

```C#

using System;
namespace CsharpStruct {
 
  // defining struct
  struct Employee {
    public int id;

    public void getId(int id) {
      Console.WriteLine("Employee Id: " + id);
    }
  }
 
  class Program {
    static void Main(string[] args) {
 
      // declare emp of struct Employee
      Employee emp;
      
      // accesses and sets struct field
      emp.id = 1;

      // accesses struct methods
      emp.getId(emp.id);

      Console.ReadLine();
    }
  }
}

```

</blockquote>

</details>

---

6. Why is class an abstract data type?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

An abstract data type is a mathematical model where the data type is defined by  its behaviour. It is not an independent data type that can be handled universally. A class containing varoius objects implies a set of data members alomg with their operations to be performed. The handling of instance variables is done through member methods of a class . This is the reason why a class is known as an abstract data type.

</blockquote>

</details>

---

7. What is the difference between the `string` keyword and the `System.String` class? 

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

There is no difference between the two.  You can use either of them in your code.

</blockquote>

</details>

<details> <summary> <b> Explanation </b> </summary>

<blockquote>

`System.String` is a class (reference type) defined the `mscorlib` in the namespace System. In other words, `System.String` is a type in the CLR.

string is a keyword in C#

Before we understand the difference, let us understand `BCL` and `FCL` terms. 

BCL is Common Language Infrastructure (CLI) available to languages like C#, A#, Boo, Cobra, F#, IronRuby, IronPython and other CLI languages.  It includes common functions such as File Read/Write or IO and database/XML interactions.  BCL was first implemented in Microsoft .NET in the form of mscorlib.dll

FCL is standard Microsoft .NET specific library containing reusable classes/assets like System, System.CodeDom, System.Collections, System.Diagnostics, System.Globalization, System.IO, System.Resources and System.Text

Now in C#, string (keyword in BCL) directly maps to System.String (an FCL type).  Similarly, intmaps directly to System.Int32. 

Here int is mapped to a integer type that is 32 bit.  But in other language, you could probably map int (keyword in BCL) to a 64 bit integer (FCL type). 

So the fact that using `string` and `System.String` in C# makes no difference is well established.

</blockquote>

</details>

---

8. Can you define Constructors?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

Whenever an instance of a class or a struct is created, its constructor is called. A class or struct may have multiple constructors that take different arguments. Constructors enable the programmer to set default values, limit instantiation, and write code that is flexible and easy to read.

A constructor is a method whose name is the same as the name of its type. Its method signature includes only an optional access modifier, the method name and its parameter list; it does not include a return type. The following example shows the constructor for a class named Person.

``` C#

public class Person
{
   private string last;
   private string first;

   public Person(string lastName, string firstName)
   {
      last = lastName;
      first = firstName;
   }

   // Remaining implementation of Person class.
}

```

</blockquote>

</details>

---

9.  What is a destructor in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

Destructor is used to clean up the memory and free the resources. But in C#, this is done by the garbage collector on its own. `System.GC.Collect()` is called internally for cleaning up. But sometimes it may be necessary to implement destructors manually.

For Example:

```C#
~Car()
{
    Console.writeline(“….”);
}
```

</blockquote>

</details>

---

10. What are the fundamental OOP concepts?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

The four basic principles of object-oriented programming are:

**Abstraction** Modeling the relevant attributes and interactions of entities as classes to define an abstract representation of a system.

**Encapsulation** Hiding the internal state and functionality of an object and only allowing access through a public set of functions.

**Inheritance** Ability to create new abstractions based on existing abstractions.

**Polymorphism** Ability to implement inherited properties or methods in different ways across multiple abstractions.

</blockquote>

</details>

---

11. Can you tell us some situations in which the characteristics of a value type make it more appropriate to use structs?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

✔️ CONSIDER defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.

❌ AVOID defining a struct unless the type has all of the following characteristics:

- It logically represents a single value, similar to primitive types (int, double, etc.).

- It has an instance size under 16 bytes.

- It is immutable.

- It will not have to be boxed frequently.

- In all other cases, you should define your types as classes.

</blockquote>

</details>

---

12.  What are the different types of classes in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

- Static Class
- Sealed Class
- Partial Class
- Abstract Class

</blockquote>

</details>

---

13. What do you understand by static class in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

Static Classes are created using a `static` keyword, if any class is marked as static it means we can't create an object of that class and the compiler will guarantee that instances (object) of this class cannot be created., just why because static classes are loaded automatically by the .NET Framework common language runtime (CLR).

**Characteristics of a static class are** :

- Static classes are sealed and therefore cannot be inherited.
- Contains only static members and static constructors.
- Static variables are stored in the heap memory.
- You can access the members of a static class by using the class name itself. 
- Static class can be public.

</blockquote>

</details>

---

14. Do you know about sealed classes? If so, keep it brief. 

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

A sealed class is a class that does not allow inheritance. Some object model designs need to allow the creation of new instances but not inheritance, if this is the case, the class should be declared as sealed. To create a sealed class in C#, the class declaration should be done as:

**Characteristics of sealed classes are**:

- We can create an instance of the sealed class in c#.
- We cannot inherit the sealed class.

</blockquote>

</details>

---

15. Can u explain a bit about partial class?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

The `partial` keyword indicates that other parts of the class, struct, or interface can be defined in the namespace. All the parts must use the `partial` keyword.

When we work on a large project and write the code in a single .cs file. It is possible to include more than one type in a single class file, but a single type's code cannot be split into sections into multiple separate files. That's why, Microsoft decided to overcome the above issue, with the introduction of something called partial types.

**Characteristics of partial class**

- Each part of a partial class should be in the same assembly or DLL.
- A partial class is only possible in the same namespace and same assembly.
- The partial class must be prefixed with the partial keyword.
- We can apply inheritance on partial class.

</blockquote>

</details>

---

16. What is an abstract class?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

Abstract classes have the following features:

- An abstract class cannot be instantiated.

- An abstract class may contain abstract methods and accessors.

- It is not possible to modify an abstract class with the sealed modifier because the two modifiers have opposite meanings. The sealed modifier prevents a class from being inherited and the abstract modifier requires a class to be inherited.

- A non-abstract class derived from an abstract class must include actual implementations of all inherited abstract methods and accessors.

For Example:

```C#

abstract class Shape
{
    public abstract int GetArea();
}

class Square : Shape
{
    private int _side;

    public Square(int n) => _side = n;

    // GetArea method is required to avoid a compile-time error.
    public override int GetArea() => _side * _side;

    static void Main()
    {
        var sq = new Square(12);
        Console.WriteLine($"Area of the square = {sq.GetArea()}");
    }
}
// Output: Area of the square = 144

```

- All the methods in an abstract class are implicitly virtual methods. Hence, the virtual keyword should not be used with any methods in the abstract class.

</blockquote>

</details>

---

17. What is the difference between the Virtual method and the Abstract method?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

**Virtual Methods**

- Virtual Method can reside in abstract and non-abstract class.
- It is not necessary to override virtual method in derived but it can be.
- Virtual method must have body ….can be overridden by `override keyword`

**Abstract methods**
Abstract Method resides in abstract class and it has no body.
Abstract Method must be overridden in non-abstract child class.

</blockquote>

</details>

---

18. How to prevent a class from being inherited?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

- By using `SEALED` keyword in class.

Once you marked the class ABC as sealed. If you will try to derive this class “ABC” in a child class “XYZ” then it will give a compiler error because ABC is marked as Sealed.

</blockquote>

</details>

---

19. When to use Interface and when Abstract class?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

Abstract class is a good choice when you are sure some methods are concrete/defined and must be implemented in the SAME WAY in all derived classes.

For example, here you can see we have an abstract class Employee. So whenever an employee is hired then might be the Project he is going to work with is not fixed. May be there are multiple projects in the company. But the role of that employee is fixed based on the designation and the Role of Employee here is Software Engineer which is kind of fixed. So, this Role method is concrete and defined in advance.

In such scenario we prefer abstract classes where some methods are defined and some just declared.

``` C#
public abstract class Employee
{
    public abstract void Project();

    public void Role()
    {
        Console.WriteLine("Software Engineer");
    }
}

```

An interface is a good choice when you know a method has to be there, but it can be implemented DIFFERENTLY by independent derived classes.

See here we have the IEmployee interface in which we have two method Project and Manager and both are just declared.
Because these methods can vary for project to project. In one project the Project name and Manager name is different and for other project it can again be different.

So these details are not fixed or concrete so we have just declared these methods not defined it.This is the use of interfaces.

```C#

interface IEmployee
{
    public void Project();

    public void Manager();
}

```

Normally we prefer Interface because it gives use the flexibility to modify the behavior at later stage.


</blockquote>

</details>

---

20.  What is the difference between fields and properties in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

A field is a member of a class or an object of any type that represents a location for storing a value, whereas a property is a class member that provides a mechanism to read, write, and compute the value of a private field.

</blockquote>

</details>

---

21.  Do interface can have Constructors?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 


NO.
Interface can only be derived from. Their object creation is not possible, so they don’t have any constructor.


</blockquote>

</details>

---

22. How is Operator Overloading achieved in C#? 

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

In C#, most of the built-in operators are available and can be overloaded or redefined using the operator keyword. The example below explains the syntax used to implement the addition operator(+) for a user-defined class.

```C#
public static Rectangle operator + (Rectangle b, Rectangle c) {
     Rectangle rectangle = new Rectangle(); 
     rectangle.length = b.length + c.length; 
     rectangle.breadth = b.breadth + c.breadth; 
     rectangle.height = b.height + c.height; 
     return rectangle; 
     } 
```

</blockquote>

</details>

---

23. What is Encapsulation? How is Encapsulation handled in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

In c#, Encapsulation is a process of binding the data members and member functions into a single unit. In c#, the class is the real-time example for encapsulation because it will combine various types of data members and member functions into a single unit. 

Generally, in c# the encapsulation is used to prevent alteration of code (data) accidentally from the outside functions. In c#, by defining the class fields with properties, we can protect the data from accidental corruption. 

If we define class fields with properties, then the encapsulated class won’t allow us to access the fields directly. Instead, we need to use getter and setter functions to read or write data based on our requirements.

```C#

using System;

using System.Text;
namespace Tutlane
{
    class User
    {
       private string location;
       private string name;
       public string Location
       {
          get
          {
             return location;
          }
          set
          {
             location = value;
          }
       }
       public string Name
       {
         get
         {
             return name;
         }
         set
         {
            name = value;
         }
       }
    }
    class Program
    {
       static void Main(string[] args)
       {
          User u = new User();
          // set accessor will invoke
          u.Name = "Suresh Dasari";
          // set accessor will invoke
          u.Location = "Hyderabad";
          // get accessor will invoke
          Console.WriteLine("Name: " + u.Name);
          // get accessor will invoke
          Console.WriteLine("Location: " + u.Location);
          Console.WriteLine("\nPress Enter Key to Exit..");
          Console.ReadLine();
       }
    }
}
```

If you observe the above example, we defined fields in encapsulated class using properties, and we are able to manipulate field values using get and set accessors of properties.

</blockquote>

</details>

---

24. What is an Interface?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

An interface defines a contract. Any class or struct that implements that contract must provide an implementation of the members defined in the interface. An interface may define a default implementation for members. It may also define static members in order to provide a single implementation for common functionality.

```C#

interface ISampleInterface
{
    void SampleMethod();
}

class ImplementationClass : ISampleInterface
{
    // Explicit interface member implementation:
    void ISampleInterface.SampleMethod()
    {
        // Method implementation.
    }

    static void Main()
    {
        // Declare an interface instance.
        ISampleInterface obj = new ImplementationClass();

        // Call the member.
        obj.SampleMethod();
    }
}

```


</blockquote>

</details>

---

25. What does the extension method do in c# and why do you need it?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

Extension methods are special static methods in a static class which enables us to add new methods to built-in types and custom types without creating new derived type. Which provides a user-defined custom functionality just like built-in methods have. For Example, String has `ToLower()`, `ToUpper()` methods. In the same way, we can create our own method.

Let's check the following example, we have created Remove() method which removes any given character/string from the original string.

```C#

public class Program
{
    public static void Main()
    {
        string sample1 = "This, is a, sample string";

        Console.WriteLine("output string : " + sample1.Remove(","));
    }   
}


public static class SampleExtensions
{
    public static string Remove(this string str1, string InputStr)
    {       
        return str1.Replace(InputStr,"");
    }
}

```

</blockquote>

</details>

---

26. Can you call the base class method without creating an instance?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

Yes, you can call the base class without instantiating it if:

- It is a static method.
- The base class is inherited by some other subclass.


</blockquote>

</details>

---

27. What is Boxing and Unboxing in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

**Boxing In C#**

- The process of Converting a Value Type (char, int, etc.) to a Reference Type(object) is called Boxing.
- Boxing is an implicit conversion process in which object type (supertype) is used.
- The Value type is always stored in Stack. The Referenced Type is stored in Heap.

**Unboxing In C#**

- The process of converting the reference type into the value type is known as Unboxing.
- It is an explicit conversion process.

</blockquote>

</details>

---

28. What are properties in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

- Properties are special types of methods that provide a flexible mechanism for classes for exposing private fields. Hence these are called accessors.


- There are two types of accessors under properties. These are:

  - The get property accessors.
  - The set property accessors.
- These accessors are used to get, set as well as compute class member values.

**The uses of different C# properties are:**

- Properties have to be either read-only or write-only.
- Every property holds some specific logic while setting values for any particular work.
- Fields in properties are contained within the class private so that they cannot be accessed from another class or outside the class's scope straightforwardly.

</blockquote>

</details>

---

29. What is the difference between late binding and early binding in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

- The Early Binding occurs at compile time while the Late Binding occurs at runtime. 
- The major difference between Early and Late Binding is that Early Binding uses the class information to resolve method calling while Late Binding uses the object to resolve method calling.

</blockquote>

</details>

---

30. What is Constructor Overloading?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Constructor Overloading allows us to call a different constructor based on the input parameters we’ve provided when creating a new instance of the class. For each accepted parameter scenario, we must define the constructor to be used. We can have as many constructor overloads as you wish.

We’ve added another constructor function that accepts a single-string input in the example below. If an input is provided, it will set the name variable to that of the input value.

```C#
class Sample
{
    public string name;
    public DateTime created_date;
    public List<string> topics;
    public string description;
    public bool draft;

    public Sample()
    {
        //This is the initial constructor method and will be used if no parameter is passed
        this.name = "Draft"; 
        this.created_date = DateTime.Now;
        this.topics = new List<string>();
        this.description = "Description";
        this.draft =  true; 
    }

    public S_Class(string name)
    {
        //This is the second constructor method and will be used if you pass a single string parameter
        //Instead of the name variable being set to "Tutorial Draft", it will be set to the value of the input parameter
        this.name = name;
        this.created_date = DateTime.Now;
        this.topics = new List<string>();
        this.description = "Description";
        this.draft =  true;
    }
}

```

</blockquote>

</details>

---

31. How does `this` keyword works in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

`this` keyword is used to refer to instance members of the current class from within an instance method or a constructor. It removes name ambiguity between method parameters and instance variables if they have the same name. 

Following are some uses of ‘this’ keyword in C#:

- It can be used to invoke any method of the current object.
- It can be used to invoke another constructor from the constructor of the same class.
- It can be used as a parameter for a method call that takes the object of the same class as a parameter.

</blockquote>

</details>

---

32. Can you brief us on C# access modifiers?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

We have four access modifiers in C#:

- **Private** - A private attribute or method can only be accessed from within the class.
- **Public** - When we declare an attribute or method public, it can be accessed from anywhere in the code.
- **Internal** - When a property or method is defined as internal, it can only be accessible from the current assembly point of that class.
- **Protected**- When we declare a method or attribute as protected, then it can only be accessed by members of that class and those who inherit it.

</blockquote>

</details>

---

33. What is method overloading?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Member overloading means creating two or more members on the same type that differ only in the number or type of parameters but have the same name. For example, in the following, the WriteLine method is overloaded:

```C#


public static class Console {
    public void WriteLine();
    public void WriteLine(string value);
    public void WriteLine(bool value);
    ...
}

```

</blockquote>

</details>

---

34. What is an object pool in .NET?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

A container that has objects which are ready to be used is known as an object pool. It helps in tracking the object which is currently in use and the total number of objects present in the pool. This brings down the need for creating and re-creating objects.

</blockquote>

</details>

---

35. Can you brief me on Method Overriding?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

- It is an approach for defining multiple methods with the same name and with the same signature means the same number, type, and order of parameters.
- Overriding of methods is not possible within the same class it must be performed under the child classes only.
- To override a parent class method under the child classes, first and foremost the child class requires to take permission from its parent.
- This is all about changing the behaviour of a method.
- This is used to implement dynamic polymorphism.
- To implement function overriding, we use the virtual keyword for the base class function and override keyword in the derived class function 

</blockquote>

</details>

---

36.  How do you inherit a class into another class in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

In C#, the colon can be used as an inheritance operator. You need to place a colon and follow it with the class name.

```C#
// WorkItem implicitly inherits from the Object class.
public class WorkItem
{
    // Static field currentID stores the job ID of the last WorkItem that
    // has been created.
    private static int currentID;

    //Properties.
    protected int ID { get; set; }
    protected string Title { get; set; }
    protected string Description { get; set; }
    protected TimeSpan jobLength { get; set; }

    // Default constructor. If a derived class does not invoke a base-
    // class constructor explicitly, the default constructor is called
    // implicitly.
    public WorkItem()
    {
        ID = 0;
        Title = "Default title";
        Description = "Default description.";
        jobLength = new TimeSpan();
    }

    // Instance constructor that has three parameters.
    public WorkItem(string title, string desc, TimeSpan joblen)
    {
        this.ID = GetNextID();
        this.Title = title;
        this.Description = desc;
        this.jobLength = joblen;
    }

    // Static constructor to initialize the static member, currentID. This
    // constructor is called one time, automatically, before any instance
    // of WorkItem or ChangeRequest is created, or currentID is referenced.
    static WorkItem() => currentID = 0;

    // currentID is a static field. It is incremented each time a new
    // instance of WorkItem is created.
    protected int GetNextID() => ++currentID;

    // Method Update enables you to update the title and job length of an
    // existing WorkItem object.
    public void Update(string title, TimeSpan joblen)
    {
        this.Title = title;
        this.jobLength = joblen;
    }

    // Virtual method override of the ToString method that is inherited
    // from System.Object.
    public override string ToString() =>
        $"{this.ID} - {this.Title}";
}

// ChangeRequest derives from WorkItem and adds a property (originalItemID)
// and two constructors.
public class ChangeRequest : WorkItem
{
    protected int originalItemID { get; set; }

    // Constructors. Because neither constructor calls a base-class
    // constructor explicitly, the default constructor in the base class
    // is called implicitly. The base class must contain a default
    // constructor.

    // Default constructor for the derived class.
    public ChangeRequest() { }

    // Instance constructor that has four parameters.
    public ChangeRequest(string title, string desc, TimeSpan jobLen,
                         int originalID)
    {
        // The following properties and the GetNexID method are inherited
        // from WorkItem.
        this.ID = GetNextID();
        this.Title = title;
        this.Description = desc;
        this.jobLength = jobLen;

        // Property originalItemID is a member of ChangeRequest, but not
        // of WorkItem.
        this.originalItemID = originalID;
    }
}

```

</blockquote>

</details>

---

37.  How can we set the class to be inherited, but prevent the method from being overridden?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

To set the class to be inherited, it needs to be declared as public. The method needs to be sealed to prevent any overrides.

</blockquote>

</details>

---

38. How can a class be set to be inherited without overriding the method in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Provided that the method isn’t virtual, it won’t be overridden. However, if the class is inheriting from a base class that contains a virtual member function, you can use the `<sealed>` modifier to avoid further overriding that member function.

</blockquote>

</details>

---

39. Can an interface inherit from another interface in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Yes, an interface can inherit from another interface in C#. It is possible for a class to inherit an interface multiple times, through base classes or interfaces it inherits. In this case, the class can only implement the interface one time if it is declared as part of the new class. If the inherited interface is not declared as part of the new class, its implementation is provided by the base class that declared it. It is possible for a base class to implement interface members using virtual members; in that case, the class inheriting the interface can change the interface behaviour by overriding the virtual members.

</blockquote>

</details>

---

40. What are the differences between method hiding and overriding in C#?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

- For hiding the base class method from the derived class, simply declare the derived class method with the new keyword.
Whereas in C#, for overriding the base class method in a derived class, you need to declare the base class method as virtual, and the derived class method as overridden.
- If a method is simply hidden then the implementation to call is based on the compile-time type of the argument "this".
Whereas if a method is overridden then the implementation to be called is based on the run-time type of the argument "this".
- New is reference-type specific and overriding is object-type specific.

</blockquote>

</details>

---
    
41. Can `this` be used within a static method?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>
    
We can't use `this` in the static method because the keyword `this` returns a reference to the current instance of the class containing it. Static methods (or any static member) do not belong to a particular instance. They exist without creating an instance of the class and call with the name of a class not by instance so we can't use this keyword in the body of static Methods, but in the case of Extension Methods, we can use it as the parameters of the function.

</blockquote>

</details>
    
---
    
