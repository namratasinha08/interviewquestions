## Technical

1. What is .NET?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 
    
.NET is a free, cross-platform, open-source developer platform for building many kinds of applications. .NET is built on a high-performance runtime that is used in production by many high-scale apps.

**Cloud apps**

 - Cloud native apps
 - Console apps
 - Serverless functions in the cloud
 - Web apps, web APIs, and microservices
 - Cross-platform client apps

**Desktop apps**

 - Games
 - Mobile apps
 - Windows apps

**Windows Desktop apps**

 - Windows Forms
 - Windows WPF
 - Universal Windows Platform (UWP)
 - Windows services

**Other app types**

 - Machine learning
 - Internet of Things (IoT)

</blockquote>

</details>

---

2. What are the important components of .NET Framework? What are their roles?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

**CLR** 
- `Common Language Runtime (CLR)` manages the execution of programs written in any language that uses the .NET Framework, for example C#, VB.Net, F# and so on. 
- CLR does various operations like memory management, security checks etc.

**CTS** 
- `CTS stands for Common Type System`. It has a set of rules which state how a data type should be declared, defined and used in the program. For example, int, string, double, all are types managed by CTS.

**CLS**
- `CLS stands for Common Language Specification` and it is a subset of CTS. It defines a set of rules and restrictions that every language must follow which runs under .NET framework. For example, you write a program in different .NET languages C#, VB.NET, J# but if their logic and output is same, then the compiled output assembly will be same for all of them.

**FCL or BCL** 
- `Framework Class Library` is the collection of classes, namespaces, interfaces and value types that are used for .NET applications. For example, String class and its methods like Replace, Substring is provided by .NET framework only and it resides in Base or Framework class library.


</blockquote>

</details>

---

3. What is an EXE?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

- EXE is an executable file that runs the application for which it is designed. 
- An EXE is produced when we build an application. 
- That's why the assemblies are loaded directly when we run an EXE. But an EXE cannot be shared with the other applications.

</blockquote>

</details>

---

4. What is a DLL?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

Dynamic Link Library (DLL) is a library that consists of code that needs to be hidden. The code is encapsulated inside this library. An application can consist of many DLLs which can be shared with the other programs and applications.

</blockquote>

</details>

---

5. What do you know about CTS?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

The common type system defines how types are declared, used, and managed in the common language runtime, and is also an important part of the runtime's support for cross-language integration. The common type system performs the following functions:

- Establishes a framework that helps enable cross-language integration, type safety, and high-performance code execution.

- Provides an object-oriented model that supports the complete implementation of many programming languages.

- Defines rules that languages must follow, which helps ensure that objects written in different languages can interact with each other.

- Provides a library that contains the primitive data types (such as Boolean, Byte, Char, Int32, and UInt64) used in application development.

</blockquote>

</details>

---

6. Can you tell us about CLS?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

CLS defines a set of features that are needed by many common applications. It also provides a sort of recipe for any language that is implemented on top of .NET on what it needs to support.

CLS is a subset of the CTS. This means that all of the rules in the CTS also apply to the CLS, unless the CLS rules are more strict. If a component is built using only the rules in the CLS, that is, it exposes only the CLS features in its API, it is said to be CLS-compliant. For instance, the `<framework-librares>` are CLS-compliant precisely because they need to work across all of the languages that are supported on .NET

</blockquote>

</details>

---

7. What is JIT?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

- JIT stands for Just In Time. JIT is a compiler that converts Intermediate Language to a Native code.
- The code is converted into Native language during execution. Native code is nothing but hardware specifications that can be read by the CPU. The native code can be stored so that it is accessible for subsequent calls.

</blockquote>

</details>

---

8. Can you differentiate Value type and Reference type?

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/Medium%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

- A value type holds a data value within its own memory space. A reference type holds a pointer to another memory location that holds the data.
- In value type, the value is copied to the new location, so there are two identical copies of the same value in the memory. In reference type, the reference is copied while the actual value remains the same.
- A value type is stored in the stack. A reference type is stored on the heap.

**Examples**: The int, float, double, struct, enum are some examples of value types. The class, array, interface are some examples of reference types.

</blockquote>

</details>

---

9. What is an assembly?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

- Assembly is unit of deployment like EXE or a DLL. When you create a code and build the solution then the .NET Framework convert it into assembly which you can see inside bin folder. 

- There are 3 types of assemblies:
  - `1. PRIVATE ASSEMBLY` - A private assembly is normally used by a single application only. It is not accessible outside.
  - `2. SHARED ASSEMBLY` - Shared assemblies are usually libraries of code, which multiple applications will use.A shared assembly is normally stored in the global assembly cache.
  - `3. SATELLITE ASSEMBLY` - A satellite Assembly is defined as an assembly with resources only, no executable code.

</blockquote>

</details>

---

10. What is GAC?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote> 

- GAC stands for `Global Assembly Cache`. 
- GAC is the place where shared assemblies get stored in a system.

</blockquote>

</details>

---

11. What are the types of memories supported in the .NET framework?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Two types of memories are present in .NET. They are:
- **Stack**: Stack is a stored-value type that keeps track of each executing thread and its location. It is used for static memory allocation.

- **Heap**: Heap is a stored reference type that keeps track of the more precise objects or data. It is used for dynamic memory allocation.

</blockquote>

</details>

---

12. What is a delegate in .NET?

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/Medium%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

A delegate is a type that represents references to methods with a particular parameter list and return type. When you instantiate a delegate, you can associate its instance with any method with a compatible signature and return type. You can invoke (or call) the method through the delegate instance.

Delegates are used to pass methods as arguments to other methods. Event handlers are nothing more than methods that are invoked through delegates. You create a custom method, and a class such as a windows control can call your method when a certain event occurs. The following example shows a delegate declaration:

```C#

public delegate int PerformCalculation(int x, int y);

```

Any method from any accessible class or struct that matches the delegate type can be assigned to the delegate. The method can be either static or an instance method. This flexibility means you can programmatically change method calls, or plug new code into existing classes.

</blockquote>

</details>

---

13. How to combine Delegates?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

A useful property of delegate objects is that multiple objects can be assigned to one delegate instance by using the `+` operator. The multicast delegate contains a list of the assigned delegates. When the multicast delegate is called, it invokes the delegates in the list, in order. Only delegates of the same type can be combined.

The `-` operator can be used to remove a component delegate from a multicast delegate.

Example:
```C#
using System;

// Define a custom delegate that has a string parameter and returns void.
delegate void CustomDel(string s);

class TestClass
{
    // Define two methods that have the same signature as CustomDel.
    static void Hello(string s)
    {
        Console.WriteLine($"  Hello, {s}!");
    }

    static void Goodbye(string s)
    {
        Console.WriteLine($"  Goodbye, {s}!");
    }

    static void Main()
    {
        // Declare instances of the custom delegate.
        CustomDel hiDel, byeDel, multiDel, multiMinusHiDel;

        // In this example, you can omit the custom delegate if you
        // want to and use Action<string> instead.
        //Action<string> hiDel, byeDel, multiDel, multiMinusHiDel;

        // Initialize the delegate object hiDel that references the
        // method Hello.
        hiDel = Hello;

        // Initialize the delegate object byeDel that references the
        // method Goodbye.
        byeDel = Goodbye;

        // The two delegates, hiDel and byeDel, are combined to
        // form multiDel.
        multiDel = hiDel + byeDel;

        // Remove hiDel from the multicast delegate, leaving byeDel,
        // which calls only the method Goodbye.
        multiMinusHiDel = multiDel - hiDel;

        Console.WriteLine("Invoking delegate hiDel:");
        hiDel("A");
        Console.WriteLine("Invoking delegate byeDel:");
        byeDel("B");
        Console.WriteLine("Invoking delegate multiDel:");
        multiDel("C");
        Console.WriteLine("Invoking delegate multiMinusHiDel:");
        multiMinusHiDel("D");
    }
}
```

**Output:**

Invoking delegate hiDel:

  Hello, A!

Invoking delegate byeDel:

  Goodbye, B!

Invoking delegate multiDel:

  Hello, C!

  Goodbye, C!

Invoking delegate multiMinusHiDel:

  Goodbye, D!


</blockquote>

</details>

---

14. Can you differentiate constants and read-only variables?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Constant fields are created using the const keyword and their value remains the same throughout the program. The Read-only fields are created using a read-only keyword and their value can be changed. Const is a compile-time constant while Read-only is a runtime constant.  

</blockquote>

</details>

---

15. What is caching in .NET?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Caching is the act of storing data in an intermediate-layer, making subsequent data retrievals faster. Conceptually, caching is a performance optimization strategy and design consideration. Caching can significantly improve app performance by making infrequently changing (or expensive to retrieve) data more readily available. 

</blockquote>

</details>

---

16. Can you tell us the different types of caching in .NET?

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

There are 3 types of caches in .NET:

- In-Memory Cache
- Persistent in-process Cache
- Distributed Cache

</blockquote>

</details>

---

17. What is MANIFEST?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Assembly metadata is stored in Manifest. Manifest contains all the metadata needed to do the following things 

- Version of assembly.
- Security identity.
- Scope of the assembly.
- Resolve references to resources and classes.


</blockquote>

</details>

---

18. When to use Delegates instead of Interface?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Both delegates and interfaces enable a class designer to separate type declarations and implementation. A given interface can be inherited and implemented by any class or struct. A delegate can be created for a method on any class, as long as the method fits the method signature for the delegate. An interface reference or a delegate can be used by an object that has no knowledge of the class that implements the interface or delegate method. 

**Use a delegate in the following circumstances:**

- An eventing design pattern is used.
- It is desirable to encapsulate a static method.
- The caller has no need to access other properties, methods, or interfaces on the object implementing the method.
- Easy composition is desired.
- A class may need more than one implementation of the method.

**Use an interface in the following circumstances:**

- There is a group of related methods that may be called.
- A class only needs one implementation of the method.
- The class using the interface will want to cast that interface to other interface or class types.
- The method being implemented is linked to the type or identity of the class: for example, comparison methods.

</blockquote>

</details>

---

19. What are Managed and Unmanaged codes?

![Easy](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/simple%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Managed code is just that a code whose execution is managed by a runtime. In this case, the runtime in question is called the Common Language Runtime or CLR, regardless of the implementation (for example, Mono, .NET Framework, or .NET Core/.NET 5+). CLR is in charge of taking the managed code, compiling it into machine code and then executing it. On top of that, runtime provides several important services such as automatic memory management, security boundaries, type safety etc.

In the unmanaged world, the programmer is in charge of pretty much everything. The actual program is, essentially, a binary that the operating system (OS) loads into memory and starts. Everything else, from memory management to security considerations are a burden of the programmer.

</blockquote>

</details>

---

20. How is a Managed code executed?

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/Medium%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

The steps for executing a managed code are as follows:

- Choose a language compiler depending on the language of the code.
- Convert the code into Intermediate language using its own compiler.
- The IL is then targeted to CLR which converts the code into native code using JIT.
- Execution of Native code.

</blockquote>

</details>

---

21. What are the different parts of an Assembly?

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/Medium%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

The different parts of an Assembly are:

i. Manifest: Also known as the assembly metadata, it has information about the version of an assembly.

ii. Type Metadata: Binary information of the program.

iii. MSIL: Microsoft Intermediate Language code.

iv. Resources: List of related files.

</blockquote>

</details>

---

22. What is the difference between namespace and assembly?

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/Medium%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Following are the differences between namespace and assembly:

- Assembly is physical grouping of logical units, Namespace, logically groups
classes.
- Namespace can span multiple assembly.


</blockquote>

</details>

---

23. Explain CAS ( CODE ACCESS SECURITY)?

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/Medium%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

.Net provides a security model that prevents unauthorized access to resources. CAS is a part of that security model. CAS is present in the CLR. It enables the users to set permissions at a granular level for the code.


</blockquote>

</details>

---

24. What is Reflection in C#?

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/Medium%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Reflection is needed when we want to determine or inspect the content of an assembly. Here, content means the metadata of an assembly like what are the methods in that assembly, what are the properties in that assembly, are they public, are they private, etc.

For example, one of the biggest implementations of Reflection is Visual Studio itself. Suppose, in visual studio, we create an object of the String class, and when we press obj. then visual studio intelligence showing all the properties, methods, fields, etc of that object. And this is possible because of Reflection in C#.

</blockquote>

</details>

---

25. What are the real-time uses of Reflection in C#?

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/Medium%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

- If we are creating applications like Visual Studio Editors where you want to show internal details 
i.e.. Metadata of an object using Intelligence.
- In unit testing sometimes, we need to invoke private methods to test whether the private members are working properly or not.
- Sometimes we would like to dump properties, methods, and assembly references to a file or probably show it on a screen.
- Late binding can also be achieved by using Reflection in C#. We can use reflection to dynamically create an instance of a type, about which we don’t have any information at compile time. So, Reflection enables us to use code that is not available at compile time.
- Consider an example where we have two alternate implementations of an interface. We want to allow the user to pick one or the other using a config file. With reflection, we can simply read the name of the class whose implementation we want to use from the config file and instantiate an instance of that class. This is another example of late binding using reflection.

</blockquote>
  
</details>

---

26. What is the difference between .dll and .exe ?

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/Medium%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Both .dll and .exe are binary files. 

DLL: Dynamic Link Library, its a library of functions. DLL files do not have an entry point-start up function(main function from where program execution starts).  It is loaded dynamically with in a process execution hence it is a in process component. DLLs are faster in performance  as compared to EXEs.  If exceptions are not handeled with in functions of DLL then it will cause process to terminate. 

EXE: Executable files, it is also a library of functions but they do have an entry point from where the program execution starts. It is an out of process component. slower in performance as compared to DLLs.

</blockquote>

</details>

---

27. What is Nuget?

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/Medium%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

For .NET (including .NET Core), the Microsoft-supported mechanism for sharing code is NuGet, which defines how packages for .NET are created, hosted, and consumed, and provides the tools for each of those roles.

Put simply, a NuGet package is a single ZIP file with the .nupkg extension that contains compiled code (DLLs), other files related to that code, and a descriptive manifest that includes information like the package's version number.

</blockquote>

</details>

---

28. What is Garbage Collector (GC)? 

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/Medium%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

The garbage collector (GC) manages the allocation and release of memory. For example, in below code you will create object object1 and object2 of classes Employee and Manager in your application. Now you will use these objects for calling any method of that class or assigning some property.

```C#

public static void Main(string[] args)
{
    Employee obj1=new Employee();
    obj1.GetSalary();

    Manager obj2=new Employee();
    obj2.GiveSalary();
}

```
But after the use you did not destroy these objects. Destroying or disposing the objects is necessary, because it is occupying memory which has to be released. So that is what garbage collector do. Release the objects when their work is done. It is done AUTOMATICALLY, no need to code for it.

</blockquote>

</details>

---

29. What is the difference between `Dispose` and `Finalize`?

![Medium](https://github.com/revaturelabs/interviewquestions/blob/dev/InterviewSpecificQuestions/ComplexityTags/Medium%20(2).svg)

<details> <summary> <b> Show Answer </b> </summary>

<blockquote>

Dispose is a method of IDisposable interface. Inside this method developer has to write the code to clean or destroy the objects which are no more required. Finalize is called by GARBAGE COLLECTOR automatically and need not to be called by the user code to run.

There is no performance cost associated with Dispose method, as the developers know when the objects will be created and where to clean up them. There is performance cost associated with Finalize method. 

For example, if GC is running in every 10 minutes but there are no objects for cleaning then it is just wasting the memory which it is using for running.

**Dispose method Example**

```C#

public class Demo:IDisposable
{
    private bool disposed=false;
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    protected virtual void Dispose(bool disposing)
    {
        if(!disposed)
        {
            if(disposing)
            {
                //clean up managed objects
            }
            //clean up unmanaged objects
            disposed=true;
        }
    }
}

```

</blockquote>

</details>

---
