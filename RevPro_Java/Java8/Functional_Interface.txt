#P1
##EASY
###BC
1. If an interface annotated with @FunctionalInterface, java complier ensures that interface has ________ method.

A. only one abstract
B. default 
C. final
D. static

Answer: A 

#P1
##EASY
###TF
2. Is @FunctionalInterface annotation is mandatory for every interface with a single abstract method?

A. Yes
B. No

Answer: B
Explanation: Not necessarily because the compiler will consider it as a functional interface when it has only one abstract method. 

#P1
##EASY
###TF
3. Is it possible to have default and static methods in the functional interface?

A. Yes
B. No

Answer: A 
Explanation: We can have any number of default and static methods but can contain only one abstract method. 

#P1
##EASY
###BC
4. How many default methods can we have in the functional interface?

A. only one 
B. two
C. many
D. four

Answer: C 
Explanation: A functional interface can have any number of default methods with only one abstract method.

#P1
##EASY
###TF
5. Is Functional Interface related to the Lambda Expression?

A. Yes
B. No

Answer: A 
Explanation:  The functional interface has been introduced in Java 8 to support the lambda expression, lambda expression is the instance of a functional interface.

#P1
##MEDIUM
###BC
6. Which of the following should be in Line 7 to print "HelloWorld" using lambda expression and functional interface?

@FunctionalInterface
interface Greetings {
	void greet();
}

public class test {
	public static void main(String[] args) {
		//Line 7
		g.greet(); 

	}
} 

A. Greetings g = () -> System.out.println("HelloWorld"); 
B. Greet g = () -> System.out.println("HelloWorld");
C. Greetings g : System.out.println("HelloWorld");
D. Greet g : System.out.println("HelloWorld");

Answer: A 

#P1
##MEDIUM
###BC
7. Which of the following is not a functional interface?.

A. Runnable 
B. Callable 
C. Comparable 
D. Iterable 

Answer: D 

#P1
##MEDIUM
###BC

8. The Anonymous classes should have _____ method so that it can be converted into lambda expression.
   
A. only one abstract
B. default 
C. final
D. static

Answer: A 

#P1
##EASY
###TF
9. Does lambda expression execute on its own? 

A. Yes
B. No

Answer: B 
Explanation : It is used to implement a method defined by a functional interface.

#P2
##MEDIUM
###BC
10. _____ is a Functional Interface but not in java.util.function package

A. Consumer 
B. Predicate 
C. Supplier 
D. Runnable  

Answer: D 

#P1
##MEDIUM
###BC
11. A functional interface can extend the interface only when there are _____ in it.

A. only one abstract
B. no abstract methods
C. no final methods
D. only one final methods

Answer: B
Explanation: If it has an abstract method then it will be an invalid functional interface.

#P1
##MEDIUM
###BC
12. _________ is also called functional interfaces, having only one abstract method and multiple default methods.

A. Single Abstract Method.
B. Lambda expression
C. Abstract Class
D. None of the above

Answer: A 

#P1
##EASY
###TF
13. Does the functional interface allows static methods?

A. Yes
B. No

Answer: A
Explanation:  JDK 8 allows static methods in the interface, before this only one abstract method is allowed in functional interface.

#P1
##EASY
###TF
14. Is Circle a Functional Interface?
public interface Circle {
    public abstract void draw();
}

A. Yes
B. No

Answer: A
Explanation: This is a functional interface, since there is only one abstract method
	
#P2
##EASY
###BC
15. Select the syntax for the Consumer Functional Interface?

A. Consumer<Integer> consumer = (value) -> System.out.println(value);
B. Consumer<Integer> consumer = () -> System.out.println(value);
C. Consumer<Integer> consumer = () -> System.out.println();
D. None of the above

Answer: A 
Explanation:  which accepts only one argument and has no return value. 


#P2
##EASY
###BC
16. Select the definition of the Predicate Functional Interface.

    A. public interface Predicate<> {
       boolean test(t);}
    B. public interface Predicate<T> {
       boolean test(T t);}
    C. public interface Predicate<T> {
       boolean test();}
    D. None of the above

Answer: B 
Explanation: A function that accepts an argument and returns a boolean value as an answer

#P2
##EASY
###BC
17. Select the definition of Supplier Functional Interface in Java8?

    A. public interface Supplier<T>{
       T get(); }
    B. @FunctionalInterface
       public interface Supplier<>{
       T get(); }
    C. @FunctionalInterface
       public interface Supplier<T>{
       T get(); }
    D. public interface Supplier<T t>{
       T get(); }


Answer: C 
Explanation: which does not take any input or argument and yet returns a single output. 

#P1
##EASY
###TF	
18. Is there any limit for static and default methods in the functional interface?

A. Yes
B. No

Answer: B 
Explanation: We can add any number of static and default methods in the functional interface in java 8.


#P1
##EASY
###BC	
19. Predict the output of the code.
@FunctionalInterface
interface Arithmetic {  
    void addition(String msg);  
    void subtraction();
}
	
A. Returns void
B. Compile time error
C. Run time error
D. None of the above

Answer: B 
Explanation: It will throw a compile time error that Arithmetic is not a functional interface, since it has 2 abstract methods.
	
#P1
##MEDIUM
###BC		
20. Pick the correct option which converts below code snippet to the Lambda expression.

import java.util.Scanner;  
public class Addition {
    public static void main(String[] args) {
    int x, y, sum;  
        Scanner sc = new Scanner(System.in);  
        System.out.print("Enter the first number: ");  
        x = sc.nextInt();  
        System.out.print("Enter the second number: ");  
        y = sc.nextInt();  
        sum = sum(x, y);  
        System.out.println("The sum of two numbers x and y is: " + sum); 
   } 
   public static int Sum(int a, int b)  {  
       int sum = a + b;  
       return sum;  
   }  
}
	

    A. public class Main{ 
         public static void main(String args[]){ 
          Sum sum = (a,b) -> a+b;
          System.out.print(sum.add(2,3));  
         }  
        }  
       interface Sum{
       int add(int a, int b);
       }
   B. public class Main{ 
         public static void main(String args[]){ 
          Sum sum = a+b;
          System.out.print(sum.add(2,3));  
         }  
        }  
       interface Sum{
       int add(int a, int b);
       }
   C. public class Main{ 
         public static void main(String args[]){ 
          Sum sum = (a,b) : a+b;
          System.out.print(sum.add(2,3));  
         }  
        }  
       interface Sum{
       int add(int a, int b);
       }
    D. None of the above

Answer: A 
Explanation: A lambda expression is a short block of code that takes in parameters and returns a value. Which is similar to methods, but they do not need a name(Function name) and they can be implemented right in the body of a method.
	
#P1
##MEDIUM
###BC		
21. Pick the correct option which converted the below Anonymous class to the lambda expression.
 
public class AnonymousClassExample  {
 
    public static void main(String[] args) {
 
        Runnable runnable = new Runnable(){
            public void run(){
                System.out.println("Convertion of Anonymous class into Lamda");
            }
        };
        runnable.run();
    }
}

A. public class AnonymousClassExample {
     public static void main(String[] args) {
        Runnable runnable = () -> {
            System.out.println("Convertion of Anonymous class into Lamda");
        };
        runnable.run();
     }
   }
B. public class AnonymousClassExample {
     public static void main(String[] args) {
        Runnable runnable ;
            System.out.println("Convertion of Anonymous class into Lamda");
        }
        runnable.run();
   }
C. public class AnonymousClassExample {
     public static void main(String[] args) {
        Runnable runnable -> ;
            System.out.println("Convertion of Anonymous class into Lamda");
        }
        runnable.run();
     }
D. None of the above
	
Answer: A 
Explanation: Functional interface can be instantiated using lambda expression instead of AnonymousClass. 

#P1
##EASY
###BC	
22. Predict the output of the below code snippet.

interface Single{  
    void say(String msg);   // abstract method  
}  
@FunctionalInterface  
interface Double extends Single{  
    void doIt();  
    System.out.println("welcome");
}


A. Compile time error
B. Run time error
C. welcome
D. None of the above

Answer: A 
Explanation: When a functional interface extends another interface it should not contain any abstract methods.
