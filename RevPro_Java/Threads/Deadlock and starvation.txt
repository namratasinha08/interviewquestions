##Java,Threads,Deadlock&Starvation

#P1
##EASY
###BC

1.Consider the following statement.
Let us assume, we have two processes A1 and A2. Now, process A1 is holding the resource R1 and is waiting for the resource R2. At the same time, the process A2 is having the resource R2 and is waiting for the resource R1. So, no one is releasing any resource, both are waiting for each other to release the resource.

Which condition is it?

A.Starvation
B.Deadlock
C.Waiting
D.None of the above

Answer:B
Explanation:Two or more threads are in block state waiting for one another to release the resource that they are having. For example, let us assume, we have two processes A1 and A2. Now, process A1 is holding the resource R1 and is waiting for the resource R2. At the same time, the process A2 is having the resource R2 and is waiting for the resource R1. So, no one is releasing any resource, both are waiting for each other to release the resource. This is called deadlock condition.

#P1
##EASY
###

2.Which of the following is said to occur when a particular thread does not get access to the object or the resource which leads to an increase in waiting and execution time?

A.Premption.
B.Deadlock.
C.Starvation.
D.Circular wait.

Answer:C
Explanation:In Starvation, Threads will wait for each other. But waiting time is not infinite after some interval of time, waiting thread gets the resources whatever is required to execute thread run() method.

#P1
##MEDIUM
###TF

3.Can we completely avoid deadlock in Java?

A.Yes.
B.No.

Answer:B.
Explanation:We cannot completely avoid deadlock but can follow these measures to them. Avoid Nested Locks - avoid giving locks to multiple threads. Avoid Unnecessary Locks - lock is for important thread not for unnecessary threads. Using Thread Join- use Thread.join with a maximum time that a thread will take to avoid a situation where a thread waiting for other thread to relaese.

#P2
##MEDIUM
###TF

4.Can we detect the deadlock condition?

A.No.
B.Yes.

Answer.B
Explanation:Deadlock situations can be detected by running the executable code on cmd and subsequently collecting the thread dump. If it occurs, the cmd will throw up a message.

#P1
##MEDIUM
###BC

5.Which of the following method suspend the thread for mentioned time duration in argument?

A.Thread.kill().
B.Thread.yield().
C.Thread.Suspend().
D.Thread.sleep().

Answer:D
Explanation:Thread.yield()-When the thread which is in the process after releasing the lock gets a fair chance to occupy the C.P.U. and can get time to complete its execution till the original thread again gets the control over the C.P.U., Thread.sleep() -Method gives chance to other Threads for the execution.

#P1
##MEDIUM
###TF

6.Is Synchronized keyword the only reason that most of the times it leads to deadlock condition?

A.No.
B.Yes.

Answer:B.
Explanation:Synchronized keyword is the only reason for deadlock situation, which allows only one thread that can access the resource at a given point of time.

#P1
##MEDIUM
###BC

7.Consider the following statements.
i.Deadlock:There are two threads waiting for each other to complete the task and none get executed.
ii.Starvation:Due to high priority process, less priority process gets blocked

Which of the above statements are correct?

A.i and ii.
B.Only i.
C.Only ii.
D.Both are incorrect.

Answer:A

#P1
##MEDIUM
###BC

8.What is the output for the following code?

class DeadlockSample extends Thread {
    static Thread mainThread;
    public void run()
    {
        System.out.println("Thread2 waiting for" +
                          " Thread1 completion");
        try {
            mainThread.join();
        }
        catch (InterruptedException e) {
            System.out.println("Thread2 execution" +
                                           " completes");
        }
    }
    public static void main(String[] args)
                   throws InterruptedException
    {
        DeadlockSample.mainThread = Thread.currentThread();
        DeadlockSample thread = new DeadlockSample();
 
        thread.start();
        System.out.println("Thread1 waiting for " +
                            "Thread2 completion");
        thread.join();
 
        System.out.println("Thread1execution" +
                                      " completes");
    }
}

A.Thread1 will complete first and Thread2 will start the process.
B.Thread2 will complete first and Thread1 will start the process.
C.Thread1 will wait for Thread2 and Thread2 will wait for Thread1.Deadlock occurs.
D.None of the above.

Answer:C
Explanation: Here the thread1 will wait for thread2 to complete and thread2 will wait for thread1 to complete. Thus, the deadlock condition occurs.

#IGNORE
##MEDIUM
###BC

9.Consider the following statements.
i.Deadlock:There are two threads waiting for each other to complete the task and none get executed.
ii.Starvation:Due to high priority process, less priority process gets blocked

Which of the above statements are correct?

A.i and ii.
B.Only i.
C.Only ii.
D.Both are incorrect.

Answer:A
